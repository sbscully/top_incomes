#!/usr/bin/env perl

use strict;
use warnings;

use feature 'say';
use Data::Dumper;
sub inspect { say Dumper @_ }

use lib 'lib';

use File::Slurp;
use Pipeline;
use JSON::Processor;
use Matrix qw(transpose);
use Traverse qw(fetch at hashref);

{
  my $in = 'data/converted.json';
  my $out = 'data/transformed.json';

  if (-f $out) { unlink $out }

  my $json = process_json { [ transform_top_incomes(@_) ] } read_file($in);
  write_file($out, $json);
}

sub transform_top_incomes {
  # Munge the Spreadsheet::Read output to get at the raw data table
  say 'parsing input...';
  my @table = pipeline @_, at(1), fetch('cell'), 'transpose', sub { splice @_, 2 };

  say "transforming $#table rows...";

  # Turn the data table rows into an array of hashrefs, with the
  # table headers as keys
  my $headers = shift @table;
  map { row_to_hashref($headers, $_) } @table;
}

sub row_to_hashref { pipeline @_, qw(zip compact_pairs flatten hashref) }

sub zip { my ($a, $b) = @_; map { [ $a->[$_], $b->[$_] ] } (0..scalar(@$a)-1) }

sub compact_pairs { grep { defined $_->[0] && defined $_->[1] } @_ }

sub flatten { map { ref $_ eq 'ARRAY' ? flatten(@$_) : $_ } @_ }